---
title: "*P. ramorum* RXLRs from all assemblies following Fletcher et al. 2018"
author: "Nick Carleson"
date: "9/16/2022"
output:
  html_document:
    code_folding: 'hide'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# knitr::opts_chunk$set(echo = FALSE)
windows_desktop_home <- "F:/P_ramorum_pacbio201904"
windows_laptop_home <- "D:/P_ramorum_pacbio201904"
linux_desktop_office <-
  "/media/nicholas.carleson@usda-ars.orst.edu/wright/P_ramorum_pacbio201904"
# linux_desktop_office <- "/home/nicholas.carleson@usda-ars.orst.edu/P_ramorum_pacbio201904"
macbook <- "/Volumes/wright/P_ramorum_pacbio201904"
# active_comp <- windows_desktop_home
# active_comp <- windows_laptop_home
# active_comp <- macbook
active_comp <- linux_desktop_office

# knitr::opts_knit$set(root.dir = windows_desktop_home)
# knitr::opts_knit$set(root.dir = windows_laptop_home)
# knitr::opts_knit$set(root.dir = linux_desktop_office)
knitr::opts_knit$set(root.dir = active_comp)
```

## Methods
From text:

The secretome was predicted using SignalP-3 (HMM Sprob >= 0.9). Additionally, we removed any protein that embed in the cell membrane. Since TMHMM can misinterpret a signal peptide (SP) as a transmembrane helix, we only removed proteins where the mean position of at least one TM was downstream of the SP cleavage site predicted from SignalP. 

We predicted RXLR candidates from secreted proteins using all non-redundant candidates from a machine learning and a regular expression search 30-60 amino acids after the predicted SP (\\w{30,60}R.LR\\w{1,40}[ED][ED][KR]).
Following Fletcher et al. 2018, proteins needed to have RXLR and either EER or WY.
Proteins could contain the RXLR motif from either Whisson or Win,
and the EER pattern from Whisson with RXLR trimmed off.
The WY proteins were inferred from HMM score using a model from Wood et al. 2019,
with a score threshold of 0 (-T 0 --seed 123).

Plan:

## 1. ORFs (bash)
## 2. Predict all possible candidates from ORFs
  a. Saving signalp results, run rxlr_motifs_effp.py effectorp3 (bash)

```{bash, eval = FALSE}
cd annotation/effectors
# Already ran a couple of the genomes by hand
# The following script only needs ORFs and uses a list as command-line input
# for calling 3_rxlr_effp3_orfsonly.sh on each genome
./run_3_rxlr_effp3_orfsonly_2022-05-26.sh
```
  
  2022-07-07: The end result was way too high for P. sojae.
  Use presence of EER *or* WY domain to filter out some candidates,
  following Fletcher et al. 2018. They used it to mine for candidates,
  I'll just use it to filter some out.
  Set yourself up here by running the WY HMM on all ORFs.
  2022-09: P. sojae still too high of a count (600).
  b. Run TMHMM on all ORFs and search for WY motif

```{bash, eval = FALSE}
./run_3_rxlr_hmmsearch-wy_orfsonly.sh
```

  c. Unhappy with the results from the Python script in Cock et al. 2013.
  Implemented the regex in effectR, hoping to replicate Haas et al. results,
  or results as originally published in Win and Whisson papers.
  This markdown only has the final method I used, pruned down from
  `Pram_rxlrs_win-re_whis-hmm_tmhmm.Rmd`
  which has the attempt mentioned above, where *P. sojae* has 2x the RXLRs as *ramorum*.
  
```{r}
rm(list = c("regex.search"))
# detach("package:effectR", unload = TRUE)
# devtools::load_all('~/Documents/effectR')
getwd()
list.files("../")
list.files(".")

devtools::load_all('../effectR')
library(seqinr)

# remotes::install_github("https://github.com/Neato-Nick/iSecrete.git")
library("tidyverse")
# library("iSecrete", quietly = TRUE, warn.conflicts = FALSE)
# devtools::load_all("~/Documents/iSecrete")
devtools::load_all("../iSecrete")
source("scripts/secretion_funcs.R")
```

  d. Remove TM proteins (R)
    1. Parse TMHMM and SignalP results into R
    2. Keep only cands with no TM (filter(mean position of a TM < SP cleave site))

```{r read_tmm_orfs}
# All isolates
sp3_fs_re <- ".*orfs-min70long.start2stop.rxlr_effp3.outsp3_tabular.tmp"
sp3_fs <- list.files(path = "annotation/effectors/output_data/",
                                pattern = sp3_fs_re, full.names = TRUE)
# TMHMM - first I ran on only the cands from Py, on 8/31/22 I ran on all ORFs
# tmm_fs_re <- ".*orfs-min70long.start2stop.rxlr_whisson_hmm_win_y.tmhmm.out"
tmm_fs_re <- ".*orfs-min70long.start2stop.tmhmm.out"
tmm_fs <- list.files(path= "annotation/effectors/output_data/",
                                pattern = tmm_fs_re, full.names = TRUE)

# make dataframe for easier function running
# and validate the signalp and tmhmm runs line up
sp3_tmm_fs <- tibble("sp3_f" = sp3_fs,
                     "tmm_f" = tmm_fs) %>%
  mutate("isolate_s" = str_extract(sp3_f, "(?<=//).*(?=\\.orfs)")) %>%
  mutate("isolate_t" = str_extract(tmm_f, "(?<=//).*(?=\\.orfs)"))

# https://stackoverflow.com/a/52978345/9120324
sp3_tmm_pass <- pmap(sp3_tmm_fs, ~ read_prune_tms(..1, ..2, ..3), .id = 'isolate') %>%
  bind_rows() %>%
  unite("ID_isolate", Protein, isolate, sep=":", remove = FALSE)
```


  e. Read list of WY HMM hits, search for [DE][DE][ER].
  The hmmsearch for WY was run in the same bash script as TMHMM 

```{r}
wy_list_re <- "*.orfs-min70long.start2stop.rxlr_WYfold_hmm.list"
read_wy_list <- function(x) {
  read_tsv(x, show_col_types = FALSE,
           col_names = c("ID"), id = "fpath") %>%
    mutate("isolate" = str_extract(fpath, "(?<=//).*(?=\\.orfs)")) %>%
  select(-fpath)
}
orfs_wys <-  list.files(path = "annotation/effectors/output_data//",
                                pattern = wy_list_re, full.names = TRUE) %>%
  map_dfr(read_wy_list) %>%
  unite("ID_isolate", ID, isolate, sep=":", remove = FALSE) %>%
  mutate("method" = "WY_hmm")
```

  f. Run our own EER search, like Whisson but just not requiring RXLR

```{r}
effectr_eer_sp3 <- function(seqs_file, sp3_file, isolate_name = NULL) {
  # Read in seqs to scan 
  orfs <- read.fasta(seqs_file)
  # Read signalp3 output from all possible candidates
  sp3 <- read_tsv(sp3_file, show_col_types = FALSE, id = "fpath") %>%
    mutate("isolate" = str_extract(fpath, ".*(?=\\.orfs)")) %>%
    mutate(isolate = str_remove(isolate, ".*data/*")) %>%
    filter(HMM_Sprob_score >= 0.9) %>%
    rename("ID" = `#ID`)
  if(is.null(isolate_name)) {
    isolate_name <- pull(sp3, isolate)[1]
  }
  
  # Search new regexes
  re_win <- regex.search(orfs, motif = "Win2007")
  re_whis <- regex.search(orfs, motif = "Whisson2007")
  re_whis_rxlr <- regex.search(orfs, motif = "Whisson2007_rxlr")
  re_whis_eer <- regex.search(orfs, motif = "Whisson2007_eer")
  
  # Get all names passing regex
  re_win_sp_names <- data.frame("method" = "Win2007",
                                "ID" = names(re_win)[names(re_win) %in% sp3$ID])
  re_whis_sp_names <- data.frame("method" = "Whis2007",
                                 "ID" = names(re_whis)[names(re_whis) %in% sp3$ID])
  re_whis_rxlr_sp_names <- data.frame("method" = "Whis_rxlr",
                                      "ID" = names(re_whis_rxlr)[names(re_whis_rxlr) %in% sp3$ID])
  re_whis_eer_sp_names <- data.frame("method" = "Whis_eer",
                                 "ID" = names(re_whis_eer)[names(re_whis_eer) %in% sp3$ID])
  
  # Compile numbers of hits before and after filtering for signalp3 threshold
  n_hits_df <- tibble("regex_method" = c("secreted_ORFs", "Win2007", "Whisson2007", "Whisson_RXLR", "Whisson_EER"),
                      "n_hits_tot" = c(NA,
                                       length(re_win),
                                       length(re_whis),
                                       length(re_whis_rxlr),
                                       length(re_whis_eer)),
                      "n_hits_sp3" = c(nrow(sp3),
                                       nrow(re_win_sp_names),
                                       nrow(re_whis_sp_names),
                                       nrow(re_whis_rxlr_sp_names),
                                       nrow(re_whis_eer_sp_names)),
                      "isolate" = rep(isolate_name, 5)
  )
  
  print(n_hits_df)
  # Choose one list of names to return from function
  # Probably EER but I don't think my summary func is working for that motif yet
  all_names_hits <- bind_rows(
    re_whis_sp_names, re_win_sp_names, re_whis_rxlr_sp_names, re_whis_eer_sp_names) %>%
    mutate("isolate" = isolate_name)
  return(all_names_hits)
}
```

```{r effectr_sp3_orfs}
# Programmatically get all files with correct extensions and run
# Read in
orf_fs_re <- ".*orfs-min70long.start2stop.fasta"
orf_fs <- list.files(path = "annotation/effectors/output_data//",
                                pattern = orf_fs_re, full.names = TRUE) %>%
  tibble("orf_f" = .) %>%
  separate(orf_f, into = c("isolate", NA),
           sep = "(?=\\.orfs-min)", remove = FALSE) %>%
  mutate(isolate = str_remove(isolate, ".*data/*"))
sp3_fs_re <- ".*orfs-min70long.start2stop.rxlr_effp3.outsp3_tabular.tmp"
sp3_fs <- list.files(path = "annotation/effectors/output_data//",
                                pattern = sp3_fs_re, full.names = TRUE) %>%
  tibble("sp3_f" = .) %>%
  separate(sp3_f, into = c("isolate", NA),
           sep = "(?=\\.orfs-min)", remove = FALSE) %>%
  mutate(isolate = str_remove(isolate, ".*data/*"))

orf_sp3_fs <- full_join(orf_fs, sp3_fs, by = "isolate") %>%
  select(orf_f, sp3_f, isolate)

# From ?map2 help docs. Not worth figuring out how to use full df mode input.
# map2(orf_sp3_fs$orf_f, orf_sp3_fs$sp3_f, test_orf_sp3)
# Update 9/9/2022: I read documentation again and found that
# map2 is for specific case of two vectors of input,
# whereas pmap_dfr is meant for any number of vectors as input
# for some reason pmap_dfr resulted in 'unused arg' error so go back to this I guess
allorfs_re_effectr <- map2(orf_sp3_fs$orf_f, orf_sp3_fs$sp3_f, effectr_eer_sp3)
allorfs_re_effectr_tb <- tibble(bind_rows(allorfs_re_effectr)) %>%
  unite("ID_isolate", ID, isolate, sep=":", remove = FALSE)
# allorfs_re_effectr_tb <- pmap_dfr(as.list(orf_sp3_fs$orf_f, orf_sp3_fs$sp3_f), effectr_eer_sp3) %>%
# allgenes_re_effectr_tb <- pmap_dfr(as.list(seqs_sp3_fs_allgenes), effectr_eer_sp3) %>%
  # tibble() %>%
  # unite("ID_isolate", ID, isolate, sep=":", remove = FALSE)
# save(allorfs_re_effectr_tb, file = "annotation/effectors/output_data/orfs_candrxlrs_manygenomes.Rd")
```

  g. Get true number of secreted proteins -
  output above `n_hits_sp3` doesn't factor in TMs.
  In a summary below, it would be like "n_unknownTM_yesSP"

```{r}
sp3_tmm_pass %>%
  distinct(ID_isolate, .keep_all = TRUE) %>%
  group_by(isolate) %>%
  summarize(n_noTM = n())
sp3_tmm_pass %>%
  filter(HMM_Sprob_score >= 0.9) %>%
  distinct(ID_isolate, .keep_all = TRUE) %>%
  group_by(isolate) %>%
  summarize(n_noTM_yesSP = n())
```

  h. Just use methods implemented from Haas supp description,
  and what Kyle Fletcher did for downy mildew work

```{r filter_methods_rfs}
# Win method
allorfs_re_effectr_tb %>%
  bind_rows(orfs_wys) %>%
  group_by(isolate) %>%
  filter((method == "Win2007")) %>%
  distinct(ID_isolate) %>%
  summarize(win_count = n(), .groups = "drop")

# Win method, noTM
allorfs_re_effectr_tb %>%
  bind_rows(orfs_wys) %>%
  group_by(isolate) %>%
  filter((method == "Win2007")) %>%
  filter(ID_isolate %in% sp3_tmm_pass$ID_isolate) %>%
  distinct(ID_isolate) %>%
  summarize(win_count_noTM = n(), .groups = "drop")

# Whisson regex effectR
allorfs_re_effectr_tb %>%
  bind_rows(orfs_wys) %>%
  group_by(isolate) %>%
  filter((method == "Whis2007")) %>%
  distinct(ID_isolate) %>%
  summarize(whis_reg_count = n(), .groups = "drop")

# Whisson regex effectR, no TM
allorfs_re_effectr_tb %>%
  bind_rows(orfs_wys) %>%
  group_by(isolate) %>%
  filter((method == "Whis2007")) %>%
  filter(ID_isolate %in% sp3_tmm_pass$ID_isolate) %>%
  distinct(ID_isolate) %>%
  summarize(whis_reg_count_noTM = n(), .groups = "drop")

# One more shot to add back some more candidates
# Whisson RXLR-EER | (Whisson RXLR | Win RXLR) & (Whis EER | WY)
allorfs_re_effectr_tb %>%
  bind_rows(orfs_wys) %>%
  mutate(isolate = str_remove(isolate, "/")) %>%
  group_by(ID_isolate, ID, isolate) %>%
  # I want the methods as a list
  summarize(methods_list = paste(method, collapse = ",")) %>%
  filter((grepl("Whis2007", methods_list)) |
           (grepl("Whis_rxlr", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list))) |
           (grepl("Win2007", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list)))) %>%
  group_by(isolate) %>%
  distinct(ID) %>%
  summarize(whis_or_whiswinrxlrEER_whiswinrxlrWY_count = n())

# and no TM's?
allorfs_re_effectr_tb %>%
  bind_rows(orfs_wys) %>%
  group_by(ID_isolate, ID, isolate) %>%
  mutate(isolate = str_remove(isolate, "/")) %>%
  # I want the methods as a list
  summarize(methods_list = paste(method, collapse = ",")) %>%
  filter((grepl("Whis2007", methods_list)) |
           (grepl("Whis_rxlr", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list))) |
           (grepl("Win2007", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list)))) %>%
  filter(ID_isolate %in% sp3_tmm_pass$ID_isolate) %>%
  group_by(isolate) %>%
  distinct(ID_isolate) %>%
  summarize(noTM_whis_or_whiswinrxlrEER_whiswinrxlrWY_count = n())

# Same as above but also allow Whisson HMM results
# NOT RUN - because I removed
# rxlr_cands_df_all for clarity and brevity
# important part is that P. sojae had >600 RXLRs and that exceeds
# what was reported in Haas by 2x.
# allorfs_re_effectr_tb %>%
#   bind_rows(orfs_wys) %>%
#   bind_rows(rxlr_cands_df_all %>%
#     filter(method == "whisson") %>%
#     filter((is_rxlr == "Y") | (is_rxlr == "hmm")) %>%
#     mutate(method = "Whis2007_pyHMM")) %>%
#   mutate(isolate = str_remove(isolate, "/")) %>%
#   mutate(ID_isolate = str_remove(ID_isolate, "/")) %>%
#   group_by(ID_isolate, ID, isolate) %>%
#   # I want the methods as a list
#   summarize(methods_list = paste(method, collapse = ",")) %>%
#   filter((grepl("Whis2007", methods_list)) |
#            (grepl("Whis_rxlr", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list))) |
#            (grepl("Win2007", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list))) |
#            (grepl("Whis2007_pyHMM", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list)))) %>%
#   filter(ID_isolate %in% sp3_tmm_pass$ID_isolate) %>%
#   group_by(isolate) %>%
#   distinct(ID_isolate) %>%
#   summarize(noTM_whis_or_whiswinrxlrEER_whiswinrxlrWY_count = n())
```

  i. Write list (r)

```{r write_cand_orfs}
outdir <- paste0(active_comp, "/annotation/effectors/output_data")
# For format, follow CRNs:
out_prefix <- "/orfs_cand_RXLRs_"

# Write each group as its own txt file
# https://stackoverflow.com/a/54807068/9120324
# rxlr_cands_df_notm %>%
  # group_by(isolate) %>%
  # July 8, 2022 added distinct
  # counts in spreadsheet weren't off but list had duplicate genes.
  # distinct(ID) %>%
  # group_walk(~ writeLines(.x$ID, paste0(outdir, out_prefix, .y$isolate, ".txt")))
# Sep 2, 2022 have a new method that Nik and I are both happy with
# Saved / worked from this tmp object to troubleshoot the file writing
allorfs_re_effectr_tb_tmp <- allorfs_re_effectr_tb %>%
  bind_rows(orfs_wys) %>%
  group_by(ID_isolate, ID, isolate) %>%
  # I want the methods as a list
  summarize(methods_list = paste(method, collapse = ",")) %>%
  filter((grepl("Whis2007", methods_list)) |
           (grepl("Whis_rxlr", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list))) |
           (grepl("Win2007", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list)))) %>%
  filter(ID_isolate %in% sp3_tmm_pass$ID_isolate)
allorfs_re_effectr_tb_tmp %>%
  ungroup() %>%
  distinct(ID_isolate, .keep_all = TRUE) %>%
  select(ID, isolate) %>%
  group_by(isolate)# %>%
  # group_walk(~ writeLines(.x$ID, paste0(outdir, out_prefix, .y$isolate, ".txt")))
remove(allorfs_re_effectr_tb_tmp)
gc()

```

## 3. Complement gff of orfs into gff of genes (bash).
  a. Stripped ORFs from PR-102 and PR-15-019 I added for Carleson et al. 2022
  b. convert list to gff with Rscript (Rscript from R)
  c. Run complement Python script
  d. Extract proteins from GFF (bash)
  
AGAT produces a lot of stdout and this can crash RStudio,
I suggest copy-paste and running in Terminal window

```{bash, eval = FALSE}
# Run each command in the for loop, commenting out steps that are already done
# Running from within Rstudio crashes the client a lot but it's not horrible
# to comment out chunks as you go
outdir="/home/nicholas.carleson@usda-ars.orst.edu/P_ramorum_pacbio201904/annotation/effectors/output_data"
rxlr_prefix="orfs_cand_RXLRs_"
# strip existing rxlr ORFs from PR-102 and PR-15-019
# grep -vP "(?<=ID=).*rxlrORF\d+" PHRA102.gff > PHRA102.strip_rxlr_orfs.gff
# grep -vP "(?<=ID=).*rxlrORF\d+" PHRA15019.gff > PHRA15019.strip_rxlr_orfs.gff
# new p sojae genome doesn't have a gff, exclude it
for orf_rxlr_list in $(ls -1 $outdir/${rxlr_prefix}*.txt | grep -v "Psoj2019.1_P6497"); do
#for orf_rxlr_list in $(ls -1 $outdir/${rxlr_prefix}*.txt | egrep "PR-102|PR-15-019"); do
  list_name=$(basename --suffix ".txt" $orf_rxlr_list)
  iso_name=$(echo $list_name | sed "s/$rxlr_prefix//")
  echo $iso_name
  orfs="$outdir/${iso_name}.orfs-min70long.start2stop.fasta"
  # Get gff w/long names from short names
  grep -w -f $orf_rxlr_list $orfs | sed 's/>//' > $outdir/${list_name}_longnames.list
  Rscript scripts/getorf_seqnames2gff.R -i $outdir/${list_name}_longnames.list
  # Now - need to get assembly name
  assembly=$(ls assemblies/${iso_name}.fasta) || assembly=$(ls assemblies/other_refs/${iso_name}.fasta)
  iso_pref=$(echo $iso_name | sed 's/genome/combine/' | sed 's/PR/PHRA/' | sed 's/-//g' | sed -e 's/_v.*//')
  # if running on just PR-102 and PR-15-019 comment out next line and use line after
  ref_gff=$(ls annotation/features/${iso_pref}.gff) || ref_gff=$(ls assemblies/other_refs/${iso_pref}.gff)
  #ref_gff=$(ls annotation/features/${iso_pref}.strip_rxlr_orfs.strip_crn_orfs.gff)
  
  # just check for overlapping genes, I dislike the merging method so hope for the best.
  agat_sp_fix_overlaping_genes.pl -f $outdir/${list_name}_longnames.gff \
  -o $outdir/${list_name}_longnames.merge_ovlp.gff
  
  agat_sp_add_start_and_stop.pl	--gff $outdir/${list_name}_longnames.gff \
  --fasta $assembly \
  --output $outdir/${list_name}_longnames.str_stp.gff

  agat_sp_manage_IDs.pl --tair --type_dependent --prefix "${iso_pref}_rxlrORF" \
  --nb 1 --gff $outdir/${list_name}_longnames.str_stp.gff \
	--output $outdir/${list_name}_longnames.str_stp.re-IDs.gff
	
	# Run first version if running normal, second if running on stripped gff
	# SUPER annoying bug - if k is specified, final gff only has overlapped feats
	#python3 scripts/complement_gff.py -r $ref_gff \
  #-s $outdir/${list_name}_longnames.str_stp.re-IDs.gff \
  #-o $outdir/${list_name}_longnames.str_stp.re-IDs.add_rxlrs.gff \
  #-l $outdir/${list_name}_longnames.str_stp.re-IDs.overlapping_ref.gff \
#  -k $outdir/${list_name}_longnames.str_stp.re-IDs.overlapped_ref.gff \
  #--unsorted
  CMD="python3 scripts/complement_gff.py -r $ref_gff \
  -s $outdir/${list_name}_longnames.str_stp.re-IDs.gff \
  -o $outdir/${list_name}_longnames.str_stp.re-IDs.add_rxlrs.gff \
  -l $outdir/${list_name}_longnames.str_stp.re-IDs.overlapping_ref.gff \
  -k $outdir/${list_name}_longnames.str_stp.re-IDs.overlapped_ref.gff \
  --unsorted"
  echo $CMD
  eval $CMD
  
  CMD="agat_sp_extract_sequences.pl \
  --gff $outdir/${list_name}_longnames.str_stp.re-IDs.add_rxlrs.gff \
  --fasta $assembly \
	-o $outdir/${list_name}_longnames.str_stp.re-IDs.add_rxlrs.fasta -p"
	echo $CMD
	# crashes Rstudio; run in terminal
	#eval $CMD
	printf "$PWD\n$assembly\t$iso_pref\n"
  echo
done

# When I needed to change the "stripped rxlr" GFF to the standard GFF:
#mv orfs_cand_RXLRs_PR-102_v3.1_longnames.str_stp.re-IDs.add_rxlrs.fasta orfs_cand_RXLRs_PR-102_v3.1_longnames.unstrip_rxlr_orfs.str_stp.re-IDs.add_rxlrs.fasta
#mv orfs_cand_RXLRs_PR-102_v3.1_longnames.str_stp.re-IDs.overlapping_ref.gff orfs_cand_RXLRs_PR-102_v3.1_longnames.unstrip_rxlr_orfs.str_stp.re-IDs.overlapping_ref.gff
#mv orfs_cand_RXLRs_PR-102_v3.1_longnames.str_stp.re-IDs.add_rxlrs.gff orfs_cand_RXLRs_PR-102_v3.1_longnames.unstrip_rxlr_orfs.str_stp.re-IDs.add_rxlrs.gff
#mv orfs_cand_RXLRs_PR-102_v3.1_longnames.strip_rxlr_orfs.str_stp.re-IDs.overlapping_ref.gff orfs_cand_RXLRs_PR-102_v3.1_longnames.str_stp.re-IDs.overlapping_ref.gff
#mv orfs_cand_RXLRs_PR-102_v3.1_longnames.strip_rxlr_orfs.str_stp.re-IDs.add_rxlrs.gff orfs_cand_RXLRs_PR-102_v3.1_longnames.str_stp.re-IDs.add_rxlrs.gff
#mv orfs_cand_RXLRs_PR-15-019_v1.1_longnames.str_stp.re-IDs.add_rxlrs.fasta orfs_cand_RXLRs_PR-15-019_v1.1_longnames.unstrip_rxlr_orfs.str_stp.re-IDs.add_rxlrs.fasta
#mv orfs_cand_RXLRs_PR-15-019_v1.1_longnames.str_stp.re-IDs.overlapping_ref.gff orfs_cand_RXLRs_PR-15-019_v1.1_longnames.unstrip_rxlr_orfs.str_stp.re-IDs.overlapping_ref.gff
#mv orfs_cand_RXLRs_PR-15-019_v1.1_longnames.str_stp.re-IDs.add_rxlrs.gff orfs_cand_RXLRs_PR-15-019_v1.1_longnames.unstrip_rxlr_orfs.str_stp.re-IDs.add_rxlrs.gff
#mv orfs_cand_RXLRs_PR-15-019_v1.1_longnames.strip_rxlr_orfs.str_stp.re-IDs.overlapping_ref.gff orfs_cand_RXLRs_PR-15-019_v1.1_longnames.str_stp.re-IDs.overlapping_ref.gff
#mv orfs_cand_RXLRs_PR-15-019_v1.1_longnames.strip_rxlr_orfs.str_stp.re-IDs.add_rxlrs.gff orfs_cand_RXLRs_PR-15-019_v1.1_longnames.str_stp.re-IDs.add_rxlrs.gff
```

## 4. Repeat 2 (r)

  a. Run WY search, SignalP, TMHMM on all predicted genes + merged-in ORFs

```{bash, eval = FALSE}
cd ~/P_ramorum_pacbio201904/annotation/effectors
# Already ran a couple of the genomes by hand
# The following script only needs ORFs and uses a list as command-line input
# for calling 3_rxlr_effp3_orfsonly.sh on each genome
#./run_4_rxlr_effp3_allgenes_2022-06-03.sh
#./run_4_rxlr_effp3_allgenes.sh
./run_4_rxlr_hmmsearch-wy_allgenes.sh
```

  b. Parse results from a. (WY, TMHMM, SignalP) into R

```{r}
# WY
wy_list_re_allgenes <- "orfs_cand_RXLRs_.*add_rxlrs.rxlr_WYfold_hmm.list"
read_wy_list_allgenes <- function(x) {
  read_tsv(x, show_col_types = FALSE,
           col_names = c("ID"), id = "fpath") %>%
    # mutate("isolate" = str_extract(fpath, "(?<=//).*(?=\\.orfs)")) %>%
    mutate("isolate" = str_extract(fpath, "(?<=orfs_cand_RXLRs_).*(?=_longnames)")) %>%
  select(-fpath)
}
allgenes_wys <-  list.files(path = "annotation/effectors/output_data//",
                                pattern = wy_list_re_allgenes, full.names = TRUE) %>%
  map_dfr(read_wy_list_allgenes) %>%
  unite("ID_isolate", ID, isolate, sep=":", remove = FALSE) %>%
  mutate("method" = "WY_hmm")
```
```{r tm_allgenes}
# Pass TM check
# n.b. signal peptide check is in motif searching func
# SignalP results are to check if TM is before | after the SP
sp3_fs_re_allgenes <- "orfs_cand_RXLRs_.*add_rxlrs.rxlr_effp3.outsp3_tabular.tmp"
sp3_fs_allgenes <- list.files(path = "annotation/effectors/output_data/",
                                pattern = sp3_fs_re_allgenes, full.names = TRUE)
tmm_fs_re_allgenes <- ".*orfs_cand_RXLRs_.*add_rxlrs.tmhmm.out"
tmm_fs_allgenes <- list.files(path= "annotation/effectors/output_data/",
                     pattern = tmm_fs_re_allgenes, full.names = TRUE)
# Dataframe for mapping, make sure filenames line up between SP and TM
sp3_tmm_fs_allgenes <- tibble("sp3_f" = sp3_fs_allgenes,
                     "tmm_f" = tmm_fs_allgenes) %>%
  # mutate("isolate_s" = str_extract(sp3_f, "(?<=//).*(?=\\.orfs)")) %>%
  mutate("isolate_s" = str_extract(sp3_f, "(?<=//orfs_cand_RXLRs_).*(?=_longnames)")) %>%
  # mutate("isolate_t" = str_extract(tmm_f, "(?<=//).*(?=\\.orfs)"))
  mutate("isolate_t" = str_extract(tmm_f, "(?<=//orfs_cand_RXLRs_).*(?=_longnames)"))
# https://stackoverflow.com/a/52978345/9120324
sp3_tmm_pass_allgenes <- pmap(sp3_tmm_fs_allgenes, ~ read_prune_tms(..1, ..2, ..3), .id = 'isolate') %>%
  bind_rows() %>%
  unite("ID_isolate", Protein, isolate, sep=":", remove = FALSE)
```

  c. Run motif searches in R and check for sig peptide
  
```{r}
# Sequence filenames
seqs_fs_re_allgenes <- "orfs_cand_RXLRs_.*_longnames.str_stp.re-IDs.add_rxlrs.fasta"
seqs_fs_allgenes <- list.files(path = "annotation/effectors/output_data/",
                               pattern = seqs_fs_re_allgenes, full.names = TRUE) %>%
  tibble("seqs_f" = .) %>%
  separate(seqs_f, into = c("isolate", NA),
           sep = "(?=_longnames)", remove = FALSE) %>%
  mutate(isolate = str_remove(isolate, ".*orfs_cand_RXLRs_"))
# SignalP filenames and join to seq fnames
seqs_sp3_fs_allgenes <- sp3_fs_allgenes %>%
  tibble("sp3_f" = .) %>%
  separate(sp3_f, into = c("isolate", NA),
           sep = "(?=_longnames)", remove = FALSE) %>%
  mutate(isolate = str_remove(isolate, ".*orfs_cand_RXLRs_")) %>%
  full_join(seqs_fs_allgenes, by = "isolate") %>%
  select(seqs_f, sp3_f, isolate)
```
```{r effectr_sp3_allgenes}
# Run motif searches - effectr_eer_sp3 defined earlier
allgenes_re_effectr_tb <- pmap_dfr(as.list(seqs_sp3_fs_allgenes), effectr_eer_sp3) %>%
  tibble() %>%
  unite("ID_isolate", ID, isolate, sep=":", remove = FALSE)
```

  d. Get true number of secreted proteins - output above `n_hits_sp3`
  doesn't factor in TMs. In a summary below,
  it would be like "n_unknownTM_yesSP"

```{r}
sp3_tmm_pass_allgenes %>%
  distinct(ID_isolate, .keep_all = TRUE) %>%
  group_by(isolate) %>%
  summarize(n_noTM = n())
sp3_tmm_pass_allgenes %>%
  filter(HMM_Sprob_score >= 0.9) %>%
  distinct(ID_isolate, .keep_all = TRUE) %>%
  group_by(isolate) %>%
  summarize(n_noTM_yesSP = n())
```

```{r}
# save(allgenes_re_effectr_tb, file = "annotation/effectors/output_data/allgenes_candrxlrs_manygenomes.Rd")
```


  e. Filter down candidates:
    * As above, Whisson | ((Whisson RXLR | Win RXLR) & (EER | WY))
    * No TM (apply list from c.: filter(mean position of a TM < SP cleave site))

```{r final_filt_cands_allgenes}
allgenes_re_effectr_tb_meths <- allgenes_re_effectr_tb %>%
  bind_rows(allgenes_wys) %>%
  group_by(ID_isolate, ID, isolate) %>%
  # I want the methods as a list
  summarize(methods_list = paste(method, collapse = ",")) %>%
  filter((grepl("Whis2007", methods_list)) |
           (grepl("Whis_rxlr", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list))) |
           (grepl("Win2007", methods_list) & (grepl("Whis_eer", methods_list) | grepl("WY_hmm", methods_list)))) %>%
  mutate(isolate = str_remove(isolate, "/"))
allgenes_re_effectr_tb_meths %>%
  group_by(isolate) %>%
  distinct(ID) %>%
  summarize(whis_or_whiswinrxlrEER_whiswinrxlrWY_count = n())
# and no TM's?
allgenes_re_effectr_tb_meths %>%
  filter(ID_isolate %in% sp3_tmm_pass_allgenes$ID_isolate) %>%
  group_by(isolate) %>%
  distinct(ID_isolate) %>%
  summarize(noTM_whis_or_whiswinrxlrEER_whiswinrxlrWY_count = n())

# Final total: 
allgenes_re_effectr_tb_meths %>%
  filter(ID_isolate %in% sp3_tmm_pass_allgenes$ID_isolate) %>%
  group_by(isolate) %>%
  distinct(ID_isolate)
```

   f. Write list (r)

```{r}
outdir <- paste0(active_comp, "/annotation/effectors/output_data")
# For format, follow CRNs:
out_prefix <- "/allgenes_RXLRs_newmethod_rerun"

# Write each group as its own txt file
# https://stackoverflow.com/a/54807068/9120324
allgenes_re_effectr_tb_meths %>%
  filter(ID_isolate %in% sp3_tmm_pass_allgenes$ID_isolate) %>%
  group_by(isolate) %>%
  distinct(ID_isolate, .keep_all = TRUE) #%>%
  # group_walk(~ writeLines(.x$ID, paste0(outdir, out_prefix, .y$isolate, ".txt")))
```

  g. Extract proteins in list from the correct GFF
  
```{bash, eval = FALSE}
# XXX The GFF below "couldn't be found",
# and wouldn't be useful anyway.
# I think I *actually* want
# sektq subseq
outdir="/home/nicholas.carleson@usda-ars.orst.edu/P_ramorum_pacbio201904/annotation/effectors/output_data"
rxlr_merged_prefix="allgenes_RXLRs"
rxlr_prefix="orfs_cand_RXLRs_"

for orf_rxlr_list in $(ls -1 $outdir/${rxlr_prefix}*.txt | grep -v "Psoj2019.1_P6497"); do
  list_name=$(basename --suffix ".txt" $orf_rxlr_list)
  iso_name=$(echo $list_name | sed "s/$rxlr_prefix//")
  echo $iso_name
  
  assembly=$(ls assemblies/${iso_name}.fasta) || assembly=$(ls assemblies/other_refs/${iso_name}.fasta)
  iso_pref=$(echo $iso_name | sed 's/genome/combine/' | sed 's/PR/PHRA/' | sed 's/-//g' | sed -e 's/_v.*//')
  prots="$outdir/${list_name}_longnames.str_stp.re-IDs.add_rxlrs.fasta"
  rxlr_list="$outdir/${rxlr_merged_prefix}_${iso_name}.txt"
  rxlr_list_name=$(basename --suffix ".txt" $rxlr_list)
  seqtk subseq $rxlr_list $prots > $outdir/${rxlr_list_name}.fasta
  
  #ref_gff=$(ls annotation/features/${iso_pref}.gff) || ref_gff=$(ls assemblies/other_refs/${iso_pref}.gff)

  #printf "$assembly\t$iso_pref\n"
  #agat_sp_extract_sequences.pl \
  #--gff $outdir/${list_name}_longnames.str_stp.re-IDs.add_rxlrs.gff \
  #--fasta $assembly \
  #-o $outdir/${list_name}_longnames.str_stp.re-IDs.add_rxlrs.fasta -p
  #echo
done
```

## 5. Check for CRNs (bash? r?)
Do this in `Pram_crns.Rmd`
check if any CRNs were also called as RXLRs.
An edge case may be a cand CRN ORF not added to genome b/c overlaps an RXLR.
Would be worth fixing ID by hand if that RXLR is an ORF I added here.

Resources:

* Pram_rxlrs_win-re_whis-hmm_tmhmm.Rmd
* Pram_effector_analysis.Rmd
* Pram_crns.Rmd

## 6. Convert nomenclature

I annotated these RXLRs in the old pacbio genomes,
I renamed all the genes and transcripts to match new contig ordering.

Here, convert to the new names.
I obtained the new names extracting the Alias field from the new GFFs,
which was populated automatically by funannotate during renaming.

```{r}
mappings <- read_tsv("annotation/features/PRall.mappings.tsv",
                     col_names = c("gene", "old_gene"), show_col_types = FALSE)
outdir <- paste0(active_comp, "/annotation/effectors/output_data")
out_prefix <- "/allgenes_RXLRs_newmethod_newprots"
allgenes_re_effectr_tb_meths %>%
  filter(ID_isolate %in% sp3_tmm_pass_allgenes$ID_isolate) %>%
  group_by(isolate) %>%
  distinct(ID_isolate, .keep_all = TRUE) %>%
  filter(grepl("PR-", isolate)) %>%
  rename("old_protein" = ID) %>%
  separate(old_protein, c("old_gene", "transcript_num"), "\\.", remove = FALSE) %>%
  left_join(mappings, by = "old_gene", multiple = "all") %>%
  filter(!is.na(gene)) %>%
  unite("protein", c("gene", "transcript_num"), sep = "-T") %>%
  group_by(isolate) %>%
  distinct(ID_isolate, .keep_all = TRUE) %>%
  select(protein, isolate) %>%
  group_walk(~ writeLines(.x$protein, paste0(outdir, out_prefix, .y$isolate, ".txt")))
```

On the cluster I checked how many of these stay if we only look at longest isoform,
they all did.

```{bash, eval = FALSE}
cd /nfs5/BPP/Grunwald_Lab/home/carleson/genome_assembly/PacBio/ramorum/meta_analysis/funannos_scaffolded/data/secretome
for prot in $(ls -1 allgenes_RXLRs_newmethod_*.txt | egrep -v "n11|all.txt"); do
  isolate=$(basename --suffix ".txt" $prot | grep -oP "(?<=newmethod_).*")
  echo $isolate
  gff=$(ls -1 ../gffs/${isolate}.longest_iso.gff)
  awk '$3 ~ /mRNA/' $gff | grep -f $prot - | wc -l
done

# Above failed because proteins were old proteins - check the new proteins
for prot in $(ls -1 allgenes_RXLRs_newmethod_newprots*.txt | egrep -v "n11|all.txt"); do
  isolate=$(basename --suffix ".txt" $prot | grep -oP "(?<=newprots).*"); echo $isolate
  gff=$(ls -1 ../gffs/${isolate}.longest_iso.gff)
  awk '$3 ~ /mRNA/' $gff | grep -oP "(?<=ID=).*(?=;Parent)" | grep -vf - $prot
done
```


